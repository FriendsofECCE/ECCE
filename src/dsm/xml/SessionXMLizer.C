/**
 * @file
 *
 *
 */
#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
using std::ends;

#include <strstream>
using std::istrstream;
using std::ostrstream;

#include <string>
using std::string;


#include <xercesc/util/XMLString.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMNode.hpp>
#include <xercesc/dom/DOMNodeFilter.hpp>
#include <xercesc/dom/DOMNodeList.hpp>
#include <xercesc/dom/DOMElement.hpp>
#include <xercesc/dom/DOMNamedNodeMap.hpp>


#include "util/EcceURL.H"
#include "util/ResourceUtils.H"
#include "util/STLUtil.H"
#include "dsm/Resource.H"
#include "dsm/EDSIFactory.H"
#include "dsm/XMLSerializer.H"
#include "dsm/BasicDOMParser.H"
#include "dsm/Session.H"
#include "dsm/SessionXMLizer.H"



const string SessionXMLizer::ROOT_ELEMENT = "Session"; 
const string SessionXMLizer::MEMBER_ELEMENT = "Task";
const string SessionXMLizer::LINK_ELEMENT = "Link";
const string SessionXMLizer::LINK_NAME_ELEMENT = "LinkName";
const string SessionXMLizer::MEMBER_LABEL = "task";

/**
 * Constructor
 */
SessionXMLizer::SessionXMLizer() : XMLSerializer()
{
}


/**
 * Destructor
 */
SessionXMLizer::~SessionXMLizer()
{
}


/**
 * Returns MIME type for Linkbase (an XML file)
 */
string SessionXMLizer::mimetype() const
{
  return "application/xml";
}


/**
 * Restore Session from an XLink Linkbase.  XLink Locator
 * elements become members and XLink Arc elements become
 * Links.  
 *
 * @param data string reference, which contains Linkbase
 * @param object reference to Session
 * @param EcceMap reference, currently these properties are ignored
 * @throw parsing the Linkbase may throw a ParseException
 */
void SessionXMLizer::deserialize(const string & data,
                                 Serializable & object, 
                                 EcceMap & properties)
  throw (ParseException)
{
  Session * session = dynamic_cast<Session *>(&object);
  if (session) {

    map<string, Resource *> memberLabels;
    int i;

    BasicDOMParser parser;
    DOMDocument *doc = 0;
    istrstream is(data.c_str());
    doc = parser.parse(is);

    // Get Root element
    DOMElement *root = doc->getDocumentElement();

    // Get Locator elements
    XMLCh *locator = XMLString::transcode(MEMBER_ELEMENT.c_str());
    DOMNodeList *locators = root->getElementsByTagName(locator);
    delete [] locator;
    for (i = 0; i < locators->getLength(); i++) {
      string memberLabel;
      DOMElement *locatorElement = (DOMElement*)locators->item(i);
      Resource * member = deserializeMember(memberLabel,
                                            (*locatorElement),
                                            session->getURL());
      if (member != 0) {
        memberLabels[memberLabel] = member;
        session->addMember(member);
      }
    }

    // Get Arc elements
    XMLCh *arc = XMLString::transcode(LINK_ELEMENT.c_str());
    DOMNodeList *arcs = root->getElementsByTagName(arc);
    delete [] arc;
    for (i = 0; i < arcs->getLength(); i++) {
      string sourceLabel = "";
      string targetLabel = "";
      string linkTypeStr = "";
      string linkName = "";
      DOMElement *arcElement = (DOMElement*)arcs->item(i);
      deserializeLink(sourceLabel, targetLabel, linkTypeStr,
                      linkName, (*arcElement));

      STLUtil::stripLeadingAndTrailingWhiteSpace(linkName);
      Resource * source = memberLabels[sourceLabel];
      Resource * target = memberLabels[targetLabel];
      Session::LinkType linkType = session->stringToLinkType(linkTypeStr);

      if (source && target && linkType != Session::UNSPECIFIED_LINKTYPE) {
        session->addLink(source, target, linkType, linkName);
      }
    }
    doc->release();
  } 
  else {
    cerr << "Dynamic cast to Session failed" << endl;
  }
}



/**
 * Save Session as an XLink Linkbase.  Members become XLink Locator
 * elements and Links become XLink Arc elements.
 *
 * @param object reference to Session
 * @param data string reference, which will contain xml generated by the
 *        serialization process
 * @param EcceMap reference, currently these properties are ignored
 */
void SessionXMLizer::serialize(const Serializable & object, 
                               string & data, 
                               EcceMap & properties)
{
  data = "";
  const Session *session =
    dynamic_cast<const Session*>(&object);

  if (session) {
    // Member Label Map
    map<Resource *, string> memberLabels; 

    // BEGIN Serialization
    ostrstream os;
    os << xmlHeader() << endl << endl;
    os << "<" << ROOT_ELEMENT
       << " xmlns:xlink=\"http://www.w3.org/1999/xlink\" " << endl
       << "xlink:type=\"extended\" >"
       << endl << endl;

    // Get/Add members (Locators)
    vector<Resource *> members = session->getMembers();
    if (members.size() > 0) {
      int i;
      for(i = 0; i < members.size(); i++) {
        string newLabel = memberLabel(i);
        os << serializeMember(members[i], newLabel);
        memberLabels[members[i]] = newLabel;
      }
    }

    // Get/Add Links (Arcs)
    vector<Session::Link *> links = session->getLinks();
    if (links.size() > 0) {
      int i;
      for (i = 0; i < links.size(); i++) {
        string linkType = session->linkTypeToString(links[i]->linkType);
        string linkName = links[i]->linkName;
        os << serializeLink(memberLabels[links[i]->source],
                            memberLabels[links[i]->target],
                            linkType,
                            linkName);
      }
    }

    // END Serialization
    os << "</" << ROOT_ELEMENT << ">" << endl << endl;
    os << ends;
    data = os.str();
  }
  else {
    cerr << "Dynamic cast to Session failed" << endl;
  }
}



/** 
 * Retrieve Locator element values.  If a valid resource type can
 * be determined, the member is retrieved and a pointer to the
 * member is returned.
 * 
 * @param member reference to pointer for new member to retrieve
 * @param memberLabel the member label, will be used to correctly
 *        deserialize the arc elements.
 * @param locatorElement a DOMElement containing an XLink 
 *        locator element.
 */
Resource * SessionXMLizer::deserializeMember(string& memberLabel, 
                                             const DOMElement& locatorElement,
                                             EcceURL baseUrl)
{
  // Get xlink:href
  string memberHref = getAttribute(locatorElement, "xlink:href");
  memberLabel = getAttribute(locatorElement, "xlink:label");

  // Get Member - href urls are relative (just the tail component)
  // Use the model's base url to create the absolute url
  // Code added to support older linkbase format where the 
  // absolute href was being stored.  May want remove this later.
  EcceURL url(memberHref);
  string tail = url.getFilePathTail();
  if (tail.empty()) {
    tail = memberHref;
  }
  string path = baseUrl.toDirString();
  EcceURL memberUrl(path + tail);
  Resource * ret = EDSIFactory::getResource(memberUrl);

  return ret;
}



/**
 * Retrieve Arc element values.
 *
 * @param sourceLabel value of the "from" attribute
 * @param targetLabel value of the "to" attribute
 * @param linkType value of the "title" attribute
 * @param arcElement a DOMElement containing an XLink Arc element
 */
void SessionXMLizer::deserializeLink(string& sourceLabel,
                                     string& targetLabel,
                                     string& linkType,
                                     string& linkName,
                                     const DOMElement& arcElement)
{
  sourceLabel = getAttribute(arcElement, "xlink:from");
  targetLabel = getAttribute(arcElement, "xlink:to");
  linkType = getAttribute(arcElement, "xlink:title"); 
  linkName = getTagValue(&arcElement, LINK_NAME_ELEMENT);
}



/**
 * Create an XLink Locator element.  If the type of member cannot be 
 * determined, then an empty string will be returned.
 *
 * @param member pointer to member which will be represented 
 *         as an XLink Locator element
 * @param memberLabel label used to identify member   
 * @return string containing Xlink Locator element
 */
string SessionXMLizer::serializeMember(Resource * member, string memberLabel)
{
  string ret = "";  

  if (member) {
    // Determine type of member
    ResourceDescriptor::CONTENTTYPE contentType = member->getContentType();

    if (contentType != ResourceDescriptor::CT_UNDEFINED) {
      ostrstream os;
      os << "<" << MEMBER_ELEMENT
         << " xlink:type=\"locator\" "
         << endl
         << "xlink:title=" << "\"" 
         << ResourceUtils::contentTypeToString(contentType) << "\" " << endl
         << "xlink:label=" << "\"" << memberLabel << "\" " << endl
         << "xlink:href=" << "\"" << member->getURL().getFilePathTail()
         << "\" >" << endl
         << "</" << MEMBER_ELEMENT << ">" << endl << endl
         << ends;
      ret = os.str();
    }
  }

  return ret;
}


/**
 * Creates an XLink Arc element.
 * 
 * @param sourceLabel label used to identify member in XLink Locator element 
 * @param targetLabel label used to identify member in XLink Locator element 
 * @param linkType description of Arc (XLink title attribute)
 * @param linkName another arc descriptor (XLink title-type element), 
 *        used to name the relationship
 * @return string containing Xlink Arc element
 */
string SessionXMLizer::serializeLink(string sourceLabel,
                                     string targetLabel,
                                     string linkType,
                                     string linkName)
{
  string ret = "";

  ostrstream os;
  os << "<" << LINK_ELEMENT;
  os << " xlink:type=\"arc\" " << endl;
  os << "xlink:title=" << "\"" << linkType << "\" " << endl;
  os << "xlink:from=" << "\"" << sourceLabel << "\" " << endl;
  os << "xlink:to=" << "\"" << targetLabel << "\" >" << endl;

  if (!linkName.empty()) {
    os << "<" << LINK_NAME_ELEMENT;
    os << " xlink:type=" << "\"" << "title" << "\"" << ">" << endl;
    os << linkName << "</" << LINK_NAME_ELEMENT << ">" << endl;
  }

  os << "</" << LINK_ELEMENT << ">" << endl << endl;
  os << ends;

  ret = os.str();

  return ret;
}


/**
 * Creates a label string used to identify members (i.e. XLink
 * Locator elements). 
 *
 * @param index integer is appended to string to create a 
 *        unique label for each member in Linkbase.
 * @return the member label - the string "task" + index
 */
string SessionXMLizer::memberLabel(int index) 
{
  ostrstream os;
  os << MEMBER_LABEL << index << ends;
  string taskLabel = os.str();
  
  return taskLabel;
}
